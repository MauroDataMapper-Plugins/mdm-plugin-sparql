// Use the pathing jar if running in windows. This is needed otherwise the classpath is too long for the idiotic windows OS
grails {
    if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
        logger.quiet('Using pathing Jar as running in Windows OS')
        pathingJar = true
    }
}

// Ensure the compile task in gradle runs all the classes tasks.
compile.dependsOn(tasks.findAll { it.name.toLowerCase().endsWith('classes') })

/*
 Create a way of only running integration tests and only running functional tests
 Whilst these should be inside separate source directories and a new task created, this approach is not the grails way, but we do not want
 to execute any functional tests until the integration ones have passed.
*/
boolean integrationTests = true
boolean functionalTests = true

if (System.getProperty('gradle.integrationTest')) {
    integrationTests = System.getProperty('gradle.integrationTest').toBoolean()
    functionalTests = !integrationTests
}
// Legacy to be deprecated soon
else if (System.getProperty('grails.integrationTest')) {
    integrationTests = System.getProperty('grails.integrationTest').toBoolean()
    functionalTests = !integrationTests
}
if (System.getProperty('gradle.functionalTest')) {
    functionalTests = System.getProperty('gradle.functionalTest').toBoolean()
    integrationTests = !functionalTests
}
// Legacy to be deprecated soon
else if (System.getProperty('grails.functionalTest')) {
    functionalTests = System.getProperty('grails.functionalTest').toBoolean()
    integrationTests = !functionalTests
}

if (tasks.findByName('integrationTest')) {

    configurations {
        integrationTestImplementation {
            extendsFrom testImplementation
        }
    }

    integrationTest {
        systemProperty 'hibernate.search.default.indexBase', "/tmp/lucene/${UUID.randomUUID().toString()}"
        System.properties.each { prop ->
            systemProperty prop.key, prop.value
        }
        systemProperty 'user.dir', workingDir
        systemProperty 'grails.run.active', 'true'
        systemProperty 'grails.env', 'test'
        enabled file("src/integration-test").isDirectory()
    }

    if (integrationTests && !functionalTests) {
        logger.log(LogLevel.WARN, '<<>> Running integration tests only <<>>')
        integrationTest {
            filter {
                excludeTestsMatching '*FunctionalSpec'
            }
        }
    } else if (functionalTests && !integrationTests) {
        logger.log(LogLevel.WARN, '<<>> Running functional tests only <<>>')
        integrationTest {
            binaryResultsDirectory.set(file("${project.testResultsDir}/functionalTest/binary"))
            filter {
                includeTestsMatching '*FunctionalSpec'
            }
            reports {
                junitXml.destination = file("${project.testResultsDir}/functionalTest")

            }
        }
        mergeTestReports.reportOn(file("${project.testResultsDir}/functionalTest/binary"))
    }
}

task('cleanTestResults', type: Delete) {
    group 'clean'
    delete 'build/test-results'
}


task('jenkinsClean') {
    group 'clean'
    dependsOn tasks.cleanLogs
    dependsOn tasks.cleanTestResults
    dependsOn tasks.cleanReports
}

test {
    systemProperty 'grails.root.base.dir', rootDir.absolutePath
    systemProperty 'grails.env', 'test'
    systemProperty 'grails.run.active', 'true'
    maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1
}

if (tasks.findByName('mergeTestReports')) {
    logger.info('Merging test reports')
    test {
        finalizedBy tasks.getByName('mergeTestReports')
        // Turn off the HTML report as this will be generated now in the correct place by the mergeTestReports task
        reports {
            html {
                enabled false
            }
        }
    }
} else {
    logger.quiet("Fixing test report path to ${file("${buildDir}/reports/tests/index.html")}")
    test {
        reports {
            html {
                destination = file("${buildDir}/reports/tests")
            }
        }
    }
}

// Handle "implementation" dependencies into the compile views tasks
AbstractCompile compile = tasks.findByName('compileGsonViews') as AbstractCompile
if (compile) {
    compile.setClasspath(compile.getClasspath() + configurations.compileClasspath)
}

compile = tasks.findByName('compileGmlViews') as AbstractCompile
if (compile) {
    compile.setClasspath(compile.getClasspath() + configurations.compileClasspath)
}

configurations {
    publishToArtifactory
}

if (!name.contains('testing')) {
    javadoc {
        if (JavaVersion.current().isJava9Compatible()) {
            options.addBooleanOption('html5', true)
        }
    }
}

project.afterEvaluate {

    project.tasks.withType(JavaCompile) { JavaCompile c ->
        c.options.fork = true
        c.options.encoding = 'UTF-8'
        //compile.options.incremental = useIncrementalJavaBuilding.toBoolean()
        c.options.compilerArgs.add('-Xlint:unchecked')
        c.options.compilerArgs.add('-Xlint:deprecation')
    }
    project.tasks.withType(GroovyCompile) { GroovyCompile c ->
        c.options.fork = true
        c.options.encoding = 'UTF-8'
    }
    project.tasks.withType(Jar) {
        Map attrs = [
            "Created-By"            : "${JavaVersion.current().toString()} JVM, ${project.gradle.gradleVersion} Gradle",
            "Specification-Title"   : "$project.rootProject.name $project.name Classes",
            "Specification-Version" : project.version,
            "Implementation-Title"  : "${project.group.toLowerCase()}.${project.name.toLowerCase()}",
            "Implementation-Version": "${project.version}.dev",
            "Implementation-Vendor" : "Oxford University",
        ]
        if (project.hasProperty('mainClass'))
            attrs.'Main-Class' = project.mainClass

        manifest {
            attributes(attrs)
        }
        // sourceCompatibility = project.sourceCompatibility
        group 'archives'
    }

    artifactory {
        publish {
            defaults {
                publications('maven')
                publishBuildInfo = true
                publishArtifacts = true
                publishPom = true
            }
        }
    }

}